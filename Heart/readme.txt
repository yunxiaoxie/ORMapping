心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制。

大部分CS的应用需要心跳机制。心跳机制一般在Server和Client都要实现，两者实现原理基本一样。Client不关心性能，怎么做都行。

如果应用是基于TCP的，可以简单地通过SO_KEEPALIVE实现心跳。TCP在设置的KeepAlive定时器到达时向对端发一个检测TCP segment，如果没收到ACK或RST，尝试几次后，就认为对端已经不存在，最后通知应用程序。这里有个缺点是，Server主动发出检测包，对性能有点影响。

应用自己实现
Client启动一个定时器，不断发心跳；
Server收到心跳后，给个回应；
Server启动一个定时器，判断Client是否存在，判断方法这里列两种：
时间差和简单标志。

    时间差策略

    收到一个心跳后，记录当前时间(记为recvedTime)。

    判断定时器时间到达，计算多久没收到心跳的时间(T)=当前时间 - recvedTime(上面记录的时间)。如果T大于某个设定值，就可以认为Client超时了。

    简单标志

    收到一个心跳后，设置连接标志为true；

    判断定时器时间到达，查看所有的标志，false的，认为对端超时了；true的将其设成false。

    上面这种方法比上面简单一些，但检测某个Client是否离线的误差有点大。

应用模拟zookeeper dubobo心跳：
微服务----心跳----注册中心，调用微服务时----先到注册中心检查是否在线----调用服务

优化点：使用google的Protocol Buffers优化实体网络传输。